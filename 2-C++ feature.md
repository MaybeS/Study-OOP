# 둘째 주, STL과 여러 C++의 특색들

## 첫째 날
오늘은 템플릿에 관한 간단한 설명과 함께 STL의 여러 함수들을 알아볼 거에요.

템플릿(template)은 함수와 클래스가 수 많은 자료형에서 동작할 수 있게 해줍니다. 이는 연산자 오버로딩이나 상속과 결합하면 매우 편한 기능을 하는데 오늘은 간단하게 만 사용하고 알아볼 것 입니다.

먼저 어떤 두 수를 더하여 결과를 반환하는 함수를 생각해 봅시다.
아마 간단하게 아래와 같이 작성할 수 있겠죠.
```
int add(int a, int b) {
  return a + b;
}
```
add(2,3) = 5로 잘 출력이 되겠죠. 

그런데 2.5나 3.9f같은 숫자가 들어가면 어떻게 될까요? add(2.5, 3.9f)를 호출해도 5가 반환이 됩니다. 2.5와 3.9f를 int로 형변환 하여 각각 2, 3이 되어 둘을 더한 값인 5가 반환 되는 것이 당연하겠죠. 그러면 실수 형태의 덧셈도 처리하고 싶다면 아무래도 아래와 같은 함수를 또 만들어 줘야 합니다.
```
double add(double a, double b) {
  return a + b;
}
```
C++에서는 **오버로딩**을 지원합니다. C에서는 같은 이름을 가진 함수를 두 개 이상 사용할 수 없었죠. 하지만 C++에서는 인자가 다르면 다른 함수로 인식하는데 이를 **오버로딩**이라고 해요. 저번 시간에 클래스의 생성자를 두 개 만든 친구들도 있을꺼에요. 기본 생성자와 다른 생성자, 이것도 오버로딩이 되었다고 볼 수 있겠죠.

헌데 이렇게 오버로딩이 있다고 해도 각 타입별로 모든 함수를 만들어야 하는것은 너무 힘들어요. 그래서 템플릿이라는게 있는데 이걸 사용하면 여러 다른 자료형을 인자로 받아 함수 내부에서 활용할 수 있어요.

이렇게 적을 수 있는데

```
template<typename T>
void add(T a, T b)
{
  return a + b;
}
```
여기서 `add(2.5, 3.9)`을 호출하면 컴파일러가 **T**를 **double**로 간주하고 6.4를 반환해 주어요. 물론 정수형 이나 다른 자료형에 대해서도 +연산이 정의되어 있다면 정상적인 연산을 할 수 있답니다.

궁극적으로 
```
template <typename T, typename R>
auto add(T a , R b) -> decltype(a+b)
{
	return a + b;
}
```
이런 형태의 add 함수를 만들 수 있어요. 반환 형식을 뒤에서 자동으로 결정해 주는 add함수에요. 조금 어려운 부분도 있으니 일단 넘어갑시다. 

*C++11이상의 컴파일러만 지원합니다.*

C++의 많은 `미리 정의된`함수들은 다들 이런 템플릿을 써서 활용도를 높이고 있어요. STL(standard Template Library)라는 C++을 위한 라이브러리가 있는데, 이걸 사용하면 엄청 간단하고 편한 코딩을 할 수 있어요.

*[STL에 관한 위키의 설명](https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%ED%85%9C%ED%94%8C%EB%A6%BF_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)*

STL은 크게 알고리즘, 컨테이너, 함수자, 반복자로 이루어진 4개의 구성 요소를 제공하고 있어요. 오늘은 그 중에서 기초적인 컨테이너 몇 개를 살펴보려 해요. 

- list: [double linked list](https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8)를 구현해 놓은 자료구조
- vector: 동적 배열과 같은 자료구조
- queue: [FIFO](https://ko.wikipedia.org/wiki/%EC%84%A0%EC%9E%85_%EC%84%A0%EC%B6%9C) 큐
- stack: [LIFO](https://ko.wikipedia.org/wiki/%ED%9B%84%EC%9E%85_%EC%84%A0%EC%B6%9C) 스택

아마 2학년의 자료구조 시간에 다 배울 내용들이지만 간단하게 설명하자면

#### linked list
연결 리스트는 각 노드가 데이터와 포인터를 가지고 있고 한 줄로 연결되어있는 방식으로 데이터를 저장하는 자료구조에요. `A->B->C`이렇게 A, B, C 노드들이 각각 A, B, C라는 값을 가지고 있다고 해봅시다. A노드는 B노드를 가리키고 있고 B노드는 C노드를 가리키고 있는 형태의 자료구조에요. 

이 자료구조의 장점은 중간에 삽입 삭제가 매우 쉽고 빠르다는 거에요. 우리가 배열에서 중간에 원소를 하나 삽입하려면 뒤에있는 모든 원소들을 한칸씩 뒤로 옮긴다음 값을 끼워넣었어야 하지만 리스트를 쓰면 `A->B` 사이에 D를 끼워넣을때 A의 포인터를 D로 바꿔주고 D의 포인터를 B로 바꿔주기만 하면 `A->D->B->C`로 됩니다. 물론 단점도 있는데, 배열 처럼 array[index] 와 같은 무작위 접근이 불가능 하다는 거에요. 리스트는 메모리상에 일렬로 정렬될 필요가 없으므로 어떤 노드 뒤에 어떤 노드가 있는 지 확인하려면 반드시 그 노드를 방문해야 해요.

#### queue
FIFO(First In, First Out), 즉 먼저 들어간 자료가 가장 먼저 나오는 선형적인 자료구조에요. queue에 2,3,4,5를 집어넣었다면 순서대로 2,3,4,5를 꺼낼 수 있답니다.

#### stack
LIFO(Last In, First Out), 즉 나중에 들어간 자료가 가장 먼저 나오는 선형적인 자료구조에요. stack에 2,3,4,5를 집어넣었다면 순서대로 5,4,3,2를 꺼낼 수 있습니다. 

*책을 쌓아두고(stack) 하나씩 꺼낸다면 가장 늦게 올려둔 책을 가장 먼저 빼야겠죠.*

어 그래서 C++의 STL은 이러한 자료구조들을 다 구현해뒀어요. 템플릿을 사용하여 말이죠! 

*여러분들은 이제 2학년에가서 STL보다 성능도 좋지 않고 보기도 좋지 않은 코드들을 과제로 만들어야 한답니다!!*

각 자료구조마다 헤더파일들이 있는데 각각 `<list>, <vector>, <queue>, <stack>` 입니다. 이들은 템플릿 클래스로 만들어 져 있어서 아래와 같이 선언하고 사용할 수 있습니다.
```
  vector<int> v;
  v.push_back(10);
  v.push_back(12);
  v.push_back(13);
  cout << v[2] << endl;
```
이러면 v라는 int자료형의 vector에 10,12,13이 순서대로 들어가 있고 `13`이 출력될 것입니다. 이 vector는 특히 많이 사용하게 될 텐데, 우리가 사용하던 배열과 매우 비슷하면서도 동적으로 크기를 알아서 조절해 줍니다. malloc을 써서 int형의 배열을 선언하면 선언한 크기만 사용할 수 있지만 vector는 그렇지 않아요. 유동적으로 그 크기를 조절하기 때문에 우리는 그저 사용만 하면 됩니다.

vector는 템플릿 클래스이므로 int나 double같은 자료형말고 다른 클래스들도 담을 수 있어요. `vector<Student> students;`라고 쓰면 저번에 만든 Student의 클래스를 vector에 담을 수 있습니다.

더 자세한 내용은 [레퍼런스](http://ko.cppreference.com/w/cpp/container/vector)에서 알아봅시다!

오늘의 과제는 vector와 동적 배열의 차이점을 몇 가지 알아오는 것 입니다.

+ 추가 과제(easy): 배열 동적할당으로 push_back, front, back, size, empty 메서드들을 구현한 클래스 만들어보기
+ 추가 과제(hard): list, stack, queue 구현해보기.



## 둘째 날
이미 하나무라로 떠난 글 입니다.
## 셋째 날
이미 네팔로 떠난 글 입니다.
