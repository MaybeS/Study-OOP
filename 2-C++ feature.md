# 둘째 주, STL과 여러 C# 둘째 주, STL과 여러 C++의 특색들

## 첫째 날
오늘은 템플릿에 관한 간단한 설명과 함께 STL의 여러 함수들을 알아볼 거에요.

템플릿(template)은 함수와 클래스가 수 많은 자료형에서 동작할 수 있게 해줍니다. 이는 연산자 오버로딩이나 상속과 결합하면 매우 편한 기능을 하는데 오늘은 간단하게 만 사용하고 알아볼 것 입니다.

먼저 어떤 두 수를 더하여 결과를 반환하는 함수를 생각해 봅시다.
아마 간단하게 아래와 같이 작성할 수 있겠죠.
```
int add(int a, int b) {
  return a + b;
}
```
add(2,3) = 5로 잘 출력이 되겠죠. 

그런데 2.5나 3.9f같은 숫자가 들어가면 어떻게 될까요? add(2.5, 3.9f)를 호출해도 5가 반환이 됩니다. 2.5와 3.9f를 int로 형변환 하여 각각 2, 3이 되어 둘을 더한 값인 5가 반환 되는 것이 당연하겠죠. 그러면 실수 형태의 덧셈도 처리하고 싶다면 아무래도 아래와 같은 함수를 또 만들어 줘야 합니다.
```
double add(double a, double b) {
  return a + b;
}
```
C++에서는 **오버로딩**을 지원합니다. C에서는 같은 이름을 가진 함수를 두 개 이상 사용할 수 없었죠. 하지만 C++에서는 인자가 다르면 다른 함수로 인식하는데 이를 **오버로딩**이라고 해요. 저번 시간에 클래스의 생성자를 두 개 만든 친구들도 있을꺼에요. 기본 생성자와 다른 생성자, 이것도 오버로딩이 되었다고 볼 수 있겠죠.

헌데 이렇게 오버로딩이 있다고 해도 각 타입별로 모든 함수를 만들어야 하는것은 너무 힘들어요. 그래서 템플릿이라는게 있는데 이걸 사용하면 여러 다른 자료형을 인자로 받아 함수 내부에서 활용할 수 있어요.

이렇게 적을 수 있는데

```
template<typename T>
T add(T a, T b)
{
  return a + b;
}
```
여기서 `add(2.5, 3.9)`을 호출하면 컴파일러가 **T**를 **double**로 간주하고 6.4를 반환해 주어요. 물론 정수형 이나 다른 자료형에 대해서도 +연산이 정의되어 있다면 정상적인 연산을 할 수 있답니다.

궁극적으로 
```
template <typename T, typename R>
auto add(T a , R b) -> decltype(a+b)
{
	return a + b;
}
```
이런 형태의 add 함수를 만들 수 있어요. 반환 형식을 뒤에서 자동으로 결정해 주는 add함수에요. 조금 어려운 부분도 있으니 일단 넘어갑시다. 

*C++11이상의 컴파일러만 지원합니다.*

C++의 많은 `미리 정의된`함수들은 다들 이런 템플릿을 써서 활용도를 높이고 있어요. STL(standard Template Library)라는 C++을 위한 라이브러리가 있는데, 이걸 사용하면 엄청 간단하고 편한 코딩을 할 수 있어요.

*[STL에 관한 위키의 설명](https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%ED%85%9C%ED%94%8C%EB%A6%BF_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)*

STL은 크게 알고리즘, 컨테이너, 함수자, 반복자로 이루어진 4개의 구성 요소를 제공하고 있어요. 오늘은 그 중에서 기초적인 컨테이너 몇 개를 살펴보려 해요. 

- list: [double linked list](https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8)를 구현해 놓은 자료구조
- vector: 동적 배열과 같은 자료구조
- queue: [FIFO](https://ko.wikipedia.org/wiki/%EC%84%A0%EC%9E%85_%EC%84%A0%EC%B6%9C) 큐
- stack: [LIFO](https://ko.wikipedia.org/wiki/%ED%9B%84%EC%9E%85_%EC%84%A0%EC%B6%9C) 스택

아마 2학년의 자료구조 시간에 다 배울 내용들이지만 간단하게 설명하자면

#### linked list
연결 리스트는 각 노드가 데이터와 포인터를 가지고 있고 한 줄로 연결되어있는 방식으로 데이터를 저장하는 자료구조에요. `A->B->C`이렇게 A, B, C 노드들이 각각 A, B, C라는 값을 가지고 있다고 해봅시다. A노드는 B노드를 가리키고 있고 B노드는 C노드를 가리키고 있는 형태의 자료구조에요. 

이 자료구조의 장점은 중간에 삽입 삭제가 매우 쉽고 빠르다는 거에요. 우리가 배열에서 중간에 원소를 하나 삽입하려면 뒤에있는 모든 원소들을 한칸씩 뒤로 옮긴다음 값을 끼워넣었어야 하지만 리스트를 쓰면 `A->B` 사이에 D를 끼워넣을때 A의 포인터를 D로 바꿔주고 D의 포인터를 B로 바꿔주기만 하면 `A->D->B->C`로 됩니다. 물론 단점도 있는데, 배열 처럼 array[index] 와 같은 무작위 접근이 불가능 하다는 거에요. 리스트는 메모리상에 일렬로 정렬될 필요가 없으므로 어떤 노드 뒤에 어떤 노드가 있는 지 확인하려면 반드시 그 노드를 방문해야 해요.

#### queue
FIFO(First In, First Out), 즉 먼저 들어간 자료가 가장 먼저 나오는 선형적인 자료구조에요. queue에 2,3,4,5를 집어넣었다면 순서대로 2,3,4,5를 꺼낼 수 있답니다.

#### stack
LIFO(Last In, First Out), 즉 나중에 들어간 자료가 가장 먼저 나오는 선형적인 자료구조에요. stack에 2,3,4,5를 집어넣었다면 순서대로 5,4,3,2를 꺼낼 수 있습니다. 

*책을 쌓아두고(stack) 하나씩 꺼낸다면 가장 늦게 올려둔 책을 가장 먼저 빼야겠죠.*

어 그래서 C++의 STL은 이러한 자료구조들을 다 구현해뒀어요. 템플릿을 사용하여 말이죠! 

*여러분들은 이제 2학년에가서 STL보다 성능도 좋지 않고 보기도 좋지 않은 코드들을 과제로 만들어야 한답니다!!*

각 자료구조마다 헤더파일들이 있는데 각각 `<list>, <vector>, <queue>, <stack>` 입니다. 이들은 템플릿 클래스로 만들어 져 있어서 아래와 같이 선언하고 사용할 수 있습니다.
```
  vector<int> v;
  v.push_back(10);
  v.push_back(12);
  v.push_back(13);
  cout << v[2] << endl;
```
이러면 v라는 int자료형의 vector에 10,12,13이 순서대로 들어가 있고 `13`이 출력될 것입니다. 이 vector는 특히 많이 사용하게 될 텐데, 우리가 사용하던 배열과 매우 비슷하면서도 동적으로 크기를 알아서 조절해 줍니다. malloc을 써서 int형의 배열을 선언하면 선언한 크기만 사용할 수 있지만 vector는 그렇지 않아요. 유동적으로 그 크기를 조절하기 때문에 우리는 그저 사용만 하면 됩니다.

vector는 템플릿 클래스이므로 int나 double같은 자료형말고 다른 클래스들도 담을 수 있어요. `vector<Student> students;`라고 쓰면 저번에 만든 Student의 클래스를 vector에 담을 수 있습니다.

더 자세한 내용은 [레퍼런스](http://ko.cppreference.com/w/cpp/container/vector)에서 알아봅시다!

오늘의 과제는 vector와 동적 배열의 차이점을 몇 가지 알아오는 것 입니다.

+ 추가 과제(easy): 배열 동적할당으로 push_back, front, back, size, empty 메서드들을 구현한 클래스 만들어보기
+ 추가 과제(hard): list, stack, queue 구현해보기.



## 둘째 날
오늘은 STL의 여러가지 반복자와 알고리즘들에 대해서 알아볼 거에요.

STL에서 반복자는 iterator라고 하는데 포인터와 상당히 비슷하며 우리가 앞서 배웠던 컨테이너들을 순회할 수 있는 객체에요. 저번 시간에 vector에 대해서 배웠는데 조금 신경 써서 메서드들을 살펴본 친구들은 begin()이나 end()같은 이상한 메서드들을 발견했을지도 몰라요. 간단한 반복자를 사용한 아래의 코드를 먼저 살펴봅시다.

*algorithm 헤더가 필요할 수 도 있습니다.*
```
vector<int> v = { 6, 9, 5 };
for(vector<int>::iterator iter = v.begin(); iter != v.end(); ++iter)
  iter += 1;
```
위의 코드는 6,9,5을 원소로 갖는 vector에서 각 원소에 1을 더하는 과정을 나타냅니다. 우리가 흔히 쓰던
```
for(int i = 0; i < v.size(); ++i)
  v[i] += 1;
```
과 별로 다를 바가 없어 보이죠. 하지만 iterator를 쓰면 []로 접근이 불가능한 다른 STL의 컨테이너에서도 순회가 가능합니다. 

begin()으로 시작해서 end()일 때 끝난다고 알고 있으면 됩니다. 물론 반 개구간이니 순방향 반복자니 양방향 반복자니 여러가지 배워야 할 것이 많이 남았지만 궁금하면 질문을 하세요!

<hr>

그리고 알고리즘들도 STL에 있는데 간단한 함수 몇 개만 알고 갑시다. 만약 어떠한 방법을 빨리 수행할 수 있는 알고리즘이 STL에 있을까 하고 궁금하다면 검색을 해보는 게 제일 좋습니다. 어차피 여러분이 STL의 모든 부분을 외우고 코딩을 할 수 있는 것도 아니고, C++ 언어의 모든 기능을 외울 수도 없기 때문입니다. 필요할 때 배우는 것이 가장 빠르고 기억에 오래 남는 학습 방법이라고 생각해요.

*<algorithm> 헤더가 필요할 수 도 있습니다.*

sort함수는 시작 점, 끝 점을 입력 받아 시작 점부터 끝 점까지 정렬을 해줍니다.
위의 6,9,5의 벡터를 `sort(v.begin(), v.end());`로 정렬하면 5,6,9의 결과를 얻을 수 있습니다.

*나중에 알고리즘 시간에 배울 수 있겠지만 여러 가지 알고리즘을 사용하여 정리합니다.*

이 sort함수는 대소 비교가 가능한 모든 원소에 대해서 정렬할 수 있는데 나중에 배울 연산자 오버라이딩을 사용하면 자신이 만든 클래스들도 일정한 순서에 따라서 정렬할 수 있습니다.

max_element함수는 시작 점, 끝 점을 입력 받아서 가장 높은 값을 가지는 iterator를 반환해 줍니다. 이 함수도 대소 비교가 가능한 모든 원소들에 대해서 사용될 수 있고 min_element라는 함수도 같은 방법으로 사용할 수 있습니다.

물론 여러 가지 알고리즘 함수들이 많이 남았지만 필요할 때 검색해보고 익히는 연습을 하도록 해봐요.

오늘의 과제는 벡터의 원소를 뒤집는 reverse함수를 구현해 보는 것 입니다. v.begin()과 v.end()를 원소로 받아서 거꾸로 뒤집어 보세요.

+ 추가 과제: 첫째 날의 추가 과제를 이미 다 했다면 포인터와 iterator가 어느 부분이 다른지 살펴보도록 해요.
+ 첫째 날의 추가 과제 제출이 미비해서 너무 어려운 내용을 하고 있나 하고 내용을 좀 줄였으니 시간이 남았다면 첫째 날의 추가 과제들을 해보세요!

## 셋째 날
오늘은 익명 함수(Anonymous functions)에 대해서 간단하게만 살펴볼 예정인데요. 물론 기술적인 부분을 설명하자면 함수 호출규약부터해서 엄청나게 많은 것들을 미리 알고 가야하지만 우리는 그냥 이런것만 있다 정도로 짚고 넘어갈 꺼에요. 너무 수박 겉핥기 식으로 배우는게 아니냐구요? 네 우리의 강의는 겉을 좀 핥아보고 맛있는 부분이 있는지 찾아보는 수업이에요.

C++11에서 추가된 비교적 새로운 기능인데, 이런 익명함수는 코드의 간결성을 높히고 지연 연산등을 지원하며 메모리상 효율적이게 불필요한 연산을 배제할 수 있는 여러가지 장점이 있어요.

익명 함수는 말 그대로 이름이 없는 함수에요. 람다 함수라고도 하는데, 이 익명함수는 C++에서는 요로코롬 생겼어요.
아래의 익명함수는 두 숫자를 받아서 더한 결과를 내놓습니다.
```
[](int a, int b)->int {
  return a + b;
}
```
- `[]`는 캡쳐 절 이라고 해서 `=`나 `&`혹은 `&[변수이름]`을 넣을 수 있어요.
만약 비어있다면 바깥에있는 변수에 접근할 수 없고, `=`를 썼다면 값을 기준으로 `&`는 참조를 기준으로 캡쳐한다는 의미에요. `&[변수이름]`으로 써서 특정 변수만 참조할 수 도 있습니다.

- `()`는 함수와 같이 매개 변수를 받는 부분이에요. 위에서는 (int a, int b)로 두개의 int 변수를 받겠죠.

- `->int`는 반환형을 명시해주는 부분이에요. 이 부분을 생력하면 기본적으로 void로 생각한답니다.

- `{}`이 부분은 람다 함수의 본문이에요. 함수를 쓰는 것과 같습니다.

람다 함수는 다른 람다 함수를 인수로 사용하거나 내부에서 또 람다 함수를 호출할 수 도 있어요. 이건 어려운 부분이니 나중에 쓰다보면 자연스럽게 쓰고있게 될지도 몰라요.

조금 사용해 봅시다.
```
int x = [](int a, int b)->int{ return a + b;}(3, 5);
```
위 식을 쓰면 x는 3과 5를 더한 8을 가지게 됩니다. 이는 `[](){}`로 이루어진 익명 함수 뒤에 `(3, 5)`와 같이 인자를 바로 적어 함수를 실행 시킬 수 있기 때문이에요.

`functional`헤더를 추가하면 사용할 수 있는 function클래스는 이런 람다 함수나 함수 객체 같은 것들을 나타낼 수 있어요. 
```
void thisIsFunction(int a) { return -a }
...
function<void(int)> function = thisIsFunction;
...
  int x = function(10); // x = -10

```

추가로 [MSDN](https://msdn.microsoft.com/ko-kr/library/dd293608.aspx)에 좋은 설명들이 많이 있어요.

오늘의 과제는 sort에 세번째 인자로 람다를 넣어서 오름차순 정렬이 아닌 내림차순 정렬을 해주는 함수를 만들어 보세요.

*인자로 begin(), end()와 같은 iterator를 받아도 되고 vector<T>같이 컨테이너를 받아도 됩니다.*

+ 추가 과제(easy): 
+ 추가 과제(hard):