# 셋째주, 이것저것 복습하기

## 첫째 날 - 함수 포인터와 함수 객체
우리는 C에서 함수 포인터를 아마 배웠을 거에요. 한번 복습해 보자면
```
int add(int a, int b)
{
  return a + b;
}
```
위와 같은 add 함수가 있을 때
```
int (*func)(int, int) = add;
```
func와 같은 함수 포인터를 만들 수 있습니다. 앞의 int는 반환 형, 괄호 안의 int, int는 인자를 나타내겠죠. 함수를 이렇게 변수처럼 저장할(가리킬) 수 있는 것은 함수명은 함수의 시작 지점에 대한 정보를 가지고 있기 때문입니다.

우리는 클래스를 배웠으니 클래스의 멤버 함수도 포인터로 만들어 볼 수 있을 것 입니다.
```
class something{
public:
  void func(int x, int y) {
    return x * y;
  }
};
```
당연한 말이지만 클래스의 멤버 함수기 때문에 `void (*func)(int, int)`와 같은 꼴로는 선언할 수 없습니다. 함수 포인터를 정의해 줄 때에는 함수의 원형과 같도록 선언해야 하는데 *어떤 클래스의 멤버 함수*인지에 해당하는 정보가 빠졌기 때문입니다. 제대로 작성하려면
```
void (something::*func)(int, int)
```
와 같이 선언해야 합니다.

함수 객체는 객체를 마치 함수처럼 호출해 사용하는 것인데, C++에서는 다양한 연산자들을 오버라이딩 해서 사요할 수 있습니다. 그 중에 () 연산자도 있어서, ()연산자에 오버라이딩을 사용하면 마치 함수처럼 사용할 수 있습니다.
```
class Func {
public:
  int add(int x) {
    sum += x;
  }
  int operator()(int a) {
    return sum * a;
  }
private:
  int sum = 0;
};
...
  Func func;
  func.add(10);
  func.add(20);
  int x = func(3);
...
```
당연하게도 x는 90이 되겠죠. 

함수 객체는 여러 장점이 있습니다. 함수 형태가 같아도 객체 타입이 다르면 다른 타입으로 인식하고, 주소를 전달하는 방식의 함수 포인터는 인라인이 될 수 없지만 함수 객체는 인라인이 될 수 있고 컴파일러가 쉽게 최적화 가능합니다.
실제로 STL의 많은 구현은 이 함수 객체를 통해서 이루어 집니다.

이제 이 함수 객체도 귀찮다고 생각한 프로그래머들은 람다를 만들어 냅니다.(*물론 꼭 그런 이유 때문은 아니지만*) 람다는 함수 객체보다 훨씬 간편합니다. 람다에 대해서는 저번 주에 간단하게 설명했었는데 많이 써봐야 익숙해질 거에요.

